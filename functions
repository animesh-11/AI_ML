"""
Write a program to find  Greatest Common Divisor (GCD) of Two Positive Numbers.
The Greatest Common Divisor (GCD) of two positive integers is the largest positive number that divides both numbers exactly without leaving a remainder.
"""

# Taking input
num1 = int(input())
num2 = int(input())

def gcd(a, b):
  a = abs(a)
  b = abs(b)
  if (a == 0):
    return b
  elif (b == 0):
    return a
  if (a > b):
    small = b
  else:
    small = a
  gcd_val = 1
  for i in range(1, small + 1):
    if ((a % i == 0) and (b % i == 0)):
      gcd_val = i
  return gcd_val

print(gcd(num1, num2))

"""
Write a program to find whether a number is prime or not.
"""

# Taking input
num = int(input())

def is_prime(n):
  if n <= 1:
    return "Not Prime"
  else:
    for i in range(2,n+1):
      if n % i == 0:
        if n == i:
          return "Prime"
        else:
          return "Not Prime"


# Print the output
print(is_prime(num))


"""
Write a program to classify input as triangle.
"""

# Taking input
side1 = int(input())
side2 = int(input())
side3 = int(input())

def classify_triangle(a, b, c):
  if (a,b,c >= 1) and (a,b,c <= 10**9):
    if (a + b > c) and (a + c > b) and (b + c > a):
      if a == b == c:
        return "Equilateral"
      elif (a==b) or (b==c) or (a==c):
        return "Isosceles"
      else:
        return "Scalene"
    else:
      return "Not a Triangle"
  else:
      return "Not a Triangle"


# Print the output
print(classify_triangle(side1, side2, side3))


"""
Write a function 'traffic_light_action(color)' that simulates a simple traffic light system with three colors: 'red', 'yellow', and 'green'.

The function should print the corresponding action for each color:

 "red": Print "Stop"
"yellow": Print "Prepare to stop"
"green": Print "Go"
If the input color is invalid, print "Invalid color".
"""
# Taking input
color = input()

def traffic_light_action(color):
  if color == "red":
    return "Stop"
  elif color == "yellow":
    return "Prepare to stop"
  elif color == "green":
    return "Go"
  else:
    return "Invalid color"
     
# Print the output
traffic_light_action(color)


"""
Write a program to find eligibility of citizenship
"""

# Taking input
age = int(input())
citizenship_input = input()

def is_eligible_to_vote(age, citizenship_input):
    if (age >= 18):
      if citizenship_input == "Yes":
        citizenship = True
      elif citizenship_input == "No":
        citizenship = False
      elif citizenship_input == "True":
        citizenship = True
      elif citizenship_input == "False":
        citizenship = False
    else:
      citizenship = False
      
    return citizenship
    
# Print the output
print(is_eligible_to_vote(age, citizenship_input))

"""
Write a program to reverse a number
"""

# Taking input
num = int(input())

def reverse_number(n):
  rev = 0
  while n > 0:
    digit = n % 10
    rev = rev * 10 + digit
    n = n // 10
  return rev
    
    
# Print the output
print(reverse_number(num))


"""
Write a program to print Pyramid patterns of number where each row contains the row number repeated
"""

# Taking input
n = int(input())

def print_pyramid(n):
  for i in range(1, n + 1):
        for j in range(i):
            print(i, end='')
        print() 
     
# Print the output
print_pyramid(n)

"""
Write a program to return differnce between square of sum and sum of squares
"""

# Taking input
n = int(input())

def difference_sum_squares(n):
    sum_of_squares = 0
    sqaure_of_sum = 0
    if (n >= 1) and (n <= 10**6):
        for i in range(1,n+1):
            sum_of_squares = sum_of_squares + i*i
        for i in range(1,n+1):
            sqaure_of_sum = sqaure_of_sum + i
        sqaure_of_sum = sqaure_of_sum * sqaure_of_sum
    return sqaure_of_sum - sum_of_squares

    
# Print the output
print(difference_sum_squares(n))

"""
Define a Python function called digit_sum_single_digit that takes a non-negative integer n and repeatedly sums its digits until the result is a single digit.
"""

# Taking input
num = int(input())

def sum_until_single_digit(num):
    if (num > 0) and (num <= 10**9):
        while num > 9:
            digit_sum = 0
            for digit in str(num):
                digit_sum += int(digit)
                num = digit_sum
        return num
    else:
        return num

# Print the output
print(sum_until_single_digit(num))

"""
Write a Python function print_zigzag(n) that prints numbers from 1 to n in a zigzag pattern across three rows. The zigzag pattern follows this repeating cycle every 4 numbers: 1st number in row 1 2nd number in row 2 3rd number in row 3 4th number in row 2 Each number is followed by a space. Positions without a number should be filled with two spaces " " to maintain alignment.
"""

def print_zigzag(n):
    row1 = ""
    row2 = ""
    row3 = ""

    for i in range(1, n + 1):
        remainder = (i - 1) % 4
        if remainder == 0:
            row1 += str(i) + " "
            row2 += "  "
            row3 += "  "
        elif remainder == 1 or remainder == 3:
            row1 += "  "
            row2 += str(i) + " "
            row3 += "  "
        elif remainder == 2:
            row1 += "  "
            row2 += "  "
            row3 += str(i) + " "

    print(row1)
    print(row2)
    print(row3)

# Example usage:
print_zigzag(10)

"""
Write a Python function 'decimal_to_binary(num)' that converts a Non-Negative Decimal Integer number to its Binary representation as a String.
"""
def decimal_to_binary(num):
    if num < 0:
        return "Input must be a non-negative integer."
    if num == 0:
        return "0"

    binary = ""
    while num > 0:
        remainder = num % 2
        binary = str(remainder) + binary
        num = num // 2
    return binary

"""
Write a program to check whether a given number is a Strong Number or not.
"""
# Taking input
n=int(input())

def factorial(n):
   if n == 0:
      return 1
   else:
      result = 1
      for i in range(1, n + 1):
         result *= i
      return result

def is_strong_number(number):
   if number < 0:
      return "Input must be a non-negative integer."
   original_num = number
   sum_of_factorials = 0
   temp = number

   if number == 0:
        sum_of_factorials = factorial(0)
   else:
      while temp > 0:
         digit = temp % 10
         sum_of_factorials += factorial(digit)
         temp //= 10

   if sum_of_factorials == original_num:
      return True
   else:
      return False


# Print the output 
print(is_strong_number(n))


"""
Write a recursive function to calculate the sum of the digits of a given number.
"""

# Taking input
n = int(input())

def sum_of_digits(n):
    if (n >= 0) and (n <= 100000):
        # Base case: if n is a single digit (0-9)
        if n < 10:
            return n
        else:
            # Recursive step: sum of last digit and sum of remaining digits
            return (n % 10) + sum_of_digits(n // 10)
       
# Print the output
print(sum_of_digits(n))


"""
 Write a function that checks whether a number is an Armstrong number. A number is Armstrong if the sum of the cubes of its digits is equal to the number itself.
"""

#Taking input
num = int(input())

def is_armstrong(num):
    if num < 0 or num > 9999:
        return "No"

    original_num = num
    sum_of_cubes = 0

  # Calculate the number of digits
    num_str = str(num)
    num_digits = len(num_str)

  # Calculate the sum of cubes of digits
    for digit_char in num_str:
        digit = int(digit_char)
        sum_of_cubes += digit ** num_digits # Use num_digits for power

  # Check if it's an Armstrong number
    if sum_of_cubes == original_num:
        return "Yes"
    else:
        return "No"

     
# Print the output
print(is_armstrong(num))


"""
Write a function 'compute_values(n)' that returns the Square, Cube, and Double of a number n. Use multiple return values and unpack them in the main program.
"""
# Taking input
n = int(input())

def compute_values(n):
    if (n >= -100) and (n<= 100):
        s = n ** 2
        c = n ** 3
        d = n * 2
        return s, c, d
   
s, c, d = compute_values(n)

# Print the output
print(s, c, d)

"""
Write a Recursive Function 'digit_product(n)' that returns the product of all digits in the number n.
"""
# Taking input
n = int(input())

def digit_product(n):
    if (n >= 0) and (n <= 100000):
        if n < 10:
            return n
        else:
             return (n % 10) * digit_product(n // 10)
    
   
# Print the output
print(digit_product(n))

"""
Write a function 'calculator(x, y, op)' that takes two numbers and an operator ('+', '-', '*', '/') and returns the result of applying the operator. Assume valid input.
"""
# Taking input
x = int(input())
y = int(input())
op = input()

def calculator(x, y, op):
    if (x >= -100) and (y <= 100):
        if op == '+':
            return x + y
        elif op == '-':
            return x - y
        elif op == '*':
            return x * y
        elif op == '/':
    # Assuming b != 0 based on constraints
            return x / y
        else:
            return "Invalid operator"
    

# Print the output
print(calculator(x, y, op))


"""
Given a positive integer N, write a program to print an odd numerical pattern consisting of N rows.



The pattern starts with the number 1. For each subsequent row, the sequence of odd numbers continues from where the previous row left off. Specifically:

The first row will contain the 1st odd number.
The second row will contain the next two odd numbers (the 2nd and 3rd in the overall sequence).
The third row will contain the next three odd numbers (the 4th, 5th, and 6th in the overall sequence), and so on.
In general, row i (from 1 to N) should contain i consecutive odd numbers from the ongoing sequence. The numbers within each row should be printed in a right-aligned manner.


Input Format:

A single integer N (1 ≤ N ≤ 15), representing the number of rows.
"""
# Taking input
N = int(input())

def print_pattern(N):
    odd = 1  # Start with the first odd number
    rows = []
    for i in range(1, N + 1):
        row_output = ""
        for j in range(i):
            row_output += str(odd) + " "
            odd += 2
        rows.append(row_output.rstrip())
    for row in rows:
        print(row)

# Print the output
print_pattern(N)

"""
Write a program that prints an N x N Identity Matrix Pattern.



An Identity Matrix is a square matrix where all the elements on the main diagonal (from the top-left to the bottom-right corner) are 1, and all other elements are 0.
"""
# Taking input
N = int(input())

for i in range(N):
    row_output = ""
    # Iterate through each column in the current row
    for j in range(N):
        # Check if the current position is on the main diagonal
        if i == j:
            row_output += "1"
        else:
            row_output += "0"
        # Add a space after each element except the last one in the row
        if j < N - 1:
            row_output += " "
    # Print the completed row
    print(row_output)

"""
Write a function 'find_nth_arithmetic_term(a, d, n_term)' that finds the 'n_term-th' value in the arithmetic progression.
"""
# Taking input
a = int(input())
d = int(input())
n_term = int(input())

def find_nth_arithmetic_term(a, d, n_term):
    if (1 <= n_term <= 100):
        nth_term = a + (n_term - 1) * d
        return nth_term

         
# Print the result
print(find_nth_arithmetic_term(a, d, n_term))

"""
Write a function 'check_perfect_number(n)' that checks whether a given number n is a perfect number. 

A perfect number is a positive integer that is equal to the sum of its proper divisors (excluding the number itself).
"""

def check_perfect_number(n):
  """
  Checks whether a given positive integer is a perfect number.

  Args:
    n: The positive integer to check (1 <= n <= 10^6).

  Returns:
    True if the number is perfect, otherwise False.
  """
  # Constraint check
  if not (1 <= n <= 10**6):
      return False # Perfect numbers are positive and within the constraint range

  # Calculate the sum of proper divisors
  sum_of_proper_divisors = 0
  # We only need to check divisors up to the square root of n
  for i in range(1, int(n**0.5) + 1):
      if n % i == 0:
          # i is a divisor
          if i * i == n:
              # If i is the square root, add it only once if it's a proper divisor
              if i != n:
                  sum_of_proper_divisors += i
          else:
              # If i is not the square root, both i and n // i are divisors
              # Add both only if they are proper divisors (i.e., not n)
              if i != n:
                  sum_of_proper_divisors += i
              if (n // i) != n:
                  sum_of_proper_divisors += n // i

  # A perfect number is equal to the sum of its proper divisors (excluding the number itself).
  # The number 1 is a special case: its only divisor is 1, sum of proper divisors is 0. 1 is not perfect.
  # The loop correctly handles 1 as sum_of_proper_divisors will be 0.

  # Check if the sum of proper divisors equals the number
  return sum_of_proper_divisors == n and n > 1 # Perfect numbers are positive integers greater than 1


# Example Usage:
# Taking input from the user
num_input = int(input("Enter a positive integer: "))

# Check and print the result
if check_perfect_number(num_input):
    print(f"{num_input} is a perfect number.")
else:
    print(f"{num_input} is not a perfect number.")
